{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Fundamentos de programaci\u00f3n con Java","text":"Apuntes en construcci\u00f3n <p>Estos apuntes se est\u00e1n actualizando por Eladio Blanco durante el curso 24/25.</p> <p>Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Programaci\u00f3n, que se imparte en el primer curso del ciclo formativo de grado superior de Desarrollo de Aplicaciones Web.</p> <p>La duraci\u00f3n del m\u00f3dulo es de 256 horas lectivas, a raz\u00f3n de 8 horas semanales, y se desarrolla a lo largo de los tres trimestres del curso. Se ha planificado bas\u00e1ndose en 4 sesiones de 2 horas lectivas por semana.</p>"},{"location":"index.html#que-voy-a-aprender","title":"\u00bfQu\u00e9 voy a aprender?","text":"<ul> <li>A ...</li> </ul>"},{"location":"index.html#resultados-de-aprendizaje","title":"Resultados de aprendizaje","text":"<ol> <li>...</li> </ol>"},{"location":"index.html#unidades-didacticas-y-temporalizacion","title":"Unidades did\u00e1cticas y temporalizaci\u00f3n","text":"<p>A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas. La primera evaluaci\u00f3n contendr\u00eda las unidades comprendidas entre la 1 y 4, y parte de la unidad 6. As\u00ed pues, desde la mitad de la  unidad 6 a la unidad 9 se ver\u00e1n en la segunda evaluaci\u00f3n.</p>"},{"location":"index.html#primera-evaluacion","title":"Primera evaluaci\u00f3n","text":"<p>Duraci\u00f3n estimada: x horas</p> <ol> <li>Arquitecturas Web (4h)<ul> <li>Cliente/Servidor.</li> <li>MVC.</li> <li>Puesta en marcha con XAMPP y Docker.</li> </ul> </li> </ol>"},{"location":"index.html#segunda-evaluacion","title":"Segunda evaluaci\u00f3n","text":"<p>Duraci\u00f3n estimada: x horas</p> <ol> <li>Frameworks PHP - Laravel (28h)<ul> <li>Instalaci\u00f3n y entornos de desarrollo</li> <li>Rutas</li> <li>Vistas y plantillas Blade</li> <li>Controladores</li> </ul> </li> </ol>"},{"location":"index.html#evaluacion","title":"Evaluaci\u00f3n","text":"<p>La nota de cada evaluaci\u00f3n y tambi\u00e9n final se calcula mediante una suma ponderada de la nota de cada Criterio de Evaluaci\u00f3n evaluado hasta el momento.</p> <p>A cada criterio se le asigna un porcentaje del total de la nota final y va asociado a un tipo de actividad que puede ser:</p> <ul> <li>Examen Teor\u00eda</li> <li>Examen Pr\u00e1cticas</li> <li>Ejercicios de clase</li> <li>Pr\u00e1cticas obligatorias</li> </ul>"},{"location":"index.html#recursos","title":"Recursos","text":"<p>Recursos del m\u00f3dulo</p> Documentaci\u00f3nSoftwareCursos PHPCursos Laravel <ul> <li> <p>Tutoriales</p> <ul> <li>Programaci\u00f3n web en PHP - mclibre.org</li> <li>Tutorial para principiantes</li> </ul> </li> <li> <p>Referencias</p> <ul> <li>Documentaci\u00f3n oficial de PHP</li> <li>Documentaci\u00f3n oficial de Laravel</li> <li>LaravelDocs - Documentaci\u00f3n no oficial de Laravel en espa\u00f1ol</li> </ul> </li> <li> <p>Recopilatorio</p> <ul> <li>Awesome PHP</li> </ul> </li> </ul> <ul> <li>IDEs<ul> <li>Visual Studio Code</li> <li>PHPStorm</li> </ul> </li> <li>Administraci\u00f3n de bases de datos<ul> <li>DBeaver</li> </ul> </li> <li> <p>Entorno de desarrollo</p> <ul> <li>Laragon</li> <li>XAMPP</li> </ul> </li> <li> <p>Entorno de desarrollo en contenedores</p> <ul> <li>Docker: Devilbox</li> <li>Docker: Laradock</li> </ul> </li> </ul> <ul> <li>OpenWebinars:<ul> <li>PHP: fundamentos</li> <li>PHP: Ampliando conceptos</li> <li>PHP y MySQL: Creando sitios din\u00e1micos</li> </ul> </li> </ul> <ul> <li>Laracasts (oficiales):<ul> <li>30 d\u00edas para aprender Laravel (ingl\u00e9s)</li> </ul> </li> <li>El rinc\u00f3n de Isma (Youtube):<ul> <li>Curso completo de Laravel 11</li> </ul> </li> <li>OpenWebinars:<ul> <li>Desarrollo Web Moderno con Laravel: De la teor\u00eda a la pr\u00e1ctica</li> </ul> </li> </ul>"},{"location":"cleancode/refactoring.html","title":"Refactorizaci\u00f3n","text":""},{"location":"cleancode/refactoring.html#introduccion","title":"Introducci\u00f3n","text":"<p>Refactorizar es cambiar el c\u00f3digo mejorando su estructura sin alterar su comportamiento.</p> <p>\"Cualquiera puede escribir c\u00f3digo que un ordenador pueda entender. Los buenos programadores son aquellos que escriben c\u00f3digo que los humanos puedan entender.\" - Martin Fowler</p> <p>A continuaci\u00f3n se presentan diferentes t\u00e9cnicas para refactorizar c\u00f3digo. En cada apartado encontrar\u00e1s el c\u00f3digo original y el refactorizado. Es posible y recomendable aplicar varias de las t\u00e9cnicas a un mismo c\u00f3digo.</p>"},{"location":"cleancode/refactoring.html#renombrar-variables-y-metodos","title":"Renombrar variables y m\u00e9todos","text":"<p>Cambiar nombres de variables y m\u00e9todos por otros adecuados para su contexto aporta una mayor legibilidad del c\u00f3digo y aclara su prop\u00f3sito.</p> C\u00f3digo mejorable... <ul> <li>No queda claro qu\u00e9 hace el m\u00e9todo o qu\u00e9 almacenan las variables.</li> </ul> rename/Conversor.java<pre><code>public class Conversor {\n    public float conv (float c) {\n        float x = c * 92678.27f;\n        return x;\n    }\n}\n</code></pre> <p>Todos los IDEs modernos tienen herramientas de refactorizaci\u00f3n que es conveniente saber utilizar para evitar despistes al realizar cambios manuales. En IntelliJ IDEA, seleccionar el m\u00e9todo/variable y <code>Refactor &gt; Rename</code>.</p> Refactorizac\u00f3n <ul> <li>Se define como constante <code>BTC_EUR_CHANGE_RATE</code>.</li> <li>El m\u00e9todo <code>conv</code> se renombra a <code>bitcoinsToEuros</code>.</li> <li>La variable <code>c</code> se renombra a <code>bitcoins</code>.</li> <li>La variable <code>x</code> se renombra a <code>euros</code>.</li> </ul> rename/refactored/Conversor.java<pre><code>public class Conversor {\n    private static final float BTC_EUR_CHANGE_RATE = 92678.27f;\n\n    public float convertBitcoinsToEuros (float bitcoins) {\n        float euros = bitcoins * EUR_BTC_CHANGE_RATE;\n        return euros;\n    }\n}\n</code></pre> <p>Recomendaci\u00f3n</p> <p>Como norma general a la hora de nombrar se suele utilizar:</p> <ul> <li>Sustantivos para variables. Ej: <code>price</code>.</li> <li>Verbos para m\u00e9todos. Ej: <code>getPrice</code>.</li> </ul>"},{"location":"cleancode/refactoring.html#encapsulacion","title":"Encapsulaci\u00f3n","text":"<p>Ocultar propiedades y m\u00e9todos que no se usen desde fuera haci\u00e9ndolos privados mejora las operaciones de acceso sin exponer detalles internos de la propia clase.</p> C\u00f3digo mejorable... encapsulate/Customer.java<pre><code>public class Customer {\n    String name;\n    int id;\n\n    public Customer() {\n        init();\n    }\n\n    public void init() {\n        name = \"Eugene Krabs\";\n        id = 42;\n    }\n\n    public String toString() {\n        return id + \":\" + name;\n    }\n}\n</code></pre> <p>En IntelliJ IDEA, seleccionar la variable y <code>Refactor &gt; Encapsulate Fields</code>.</p> Refactorizac\u00f3n <ul> <li>Se definen como privados los atributos <code>name</code> e <code>id</code>.    </li> <li>Se a\u00f1aden sus getters y setters correspondientes.</li> <li>Se define como privado el m\u00e9todo <code>init</code> porque s\u00f3lo se usa internamente.</li> </ul> rename/refactored/Conversor.java<pre><code>public class Customer {\n    private String name;\n    private int id;\n\n    public Customer() {\n        init();\n    }\n\n    private void init() {\n        setName(\"Eugene Krabs\");\n        setId(42);\n    }\n\n    String getName(){ return name; }\n    void setName(String name){ this.name = name; }\n\n    int getId(){ return id; }\n    void setId(int id){ this.id = id; }\n\n    public String toString() {\n        return getId() + \":\" + getName();\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#extraer-constantes","title":"Extraer constantes","text":"<p>Extraer valores literales a constantes para aclarar el prop\u00f3sito del valor, aumentar la legibilidad, facilitar su cambio o incluso facilitar el uso de valores complejos como PI.</p> C\u00f3digo mejorable... magicnumbers/PasswordGenerator.java<pre><code>public class PasswordGenerator {\n    private Random random = new Random();\n    private String characters = \"abcdefghijkmnopqrstuvwxyz23456789\";\n\n    public String generatePassword(int length) throws Exception {\n        if (length &lt; 6 || length &gt; 15) {\n            throw new Exception(\"Wrong password length: \" + length);\n        } else {\n            String password = \"\";\n\n            for (int i = 0; i &lt; length; i++)\n                password += characters.charAt(random.nextInt(characters.length()));\n\n            return password;\n        }\n    }\n}\n</code></pre> <p>En IntelliJ IDEA, seleccionar el valor literal y <code>Refactor &gt; Introduce Constant</code>.</p> Refactorizaci\u00f3n <ul> <li>Crear constantes <code>MAX_PASSWORD_LENGTH</code> y <code>MIN_PASSWORD_LENGTH</code> para los valores literales 15 y 6.</li> </ul> magicnumbers/refactored/PasswordGenerator.java<pre><code>public class PasswordGenerator { \n    private static final int MAX_PASSWORD_LENGTH = 15;\n    private static final int MIN_PASSWORD_LENGTH = 6;\n    private Random random = new Random();\n    private String characters = \"abcdefghijkmnopqrstuvwxyz23456789\";\n\n    public String generatePassword(int length) throws Exception {\n        if (length &lt; MIN_PASSWORD_LENGTH || length &gt; MAX_PASSWORD_LENGTH) {\n            throw new Exception(\"Wrong password length: \" + length);\n        } else {\n            String password = \"\";\n\n            for (int i = 0; i &lt; length; i++)\n                password += characters.charAt(random.nextInt(characters.length()));\n\n            return password;\n        }\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#extraer-metodos","title":"Extraer m\u00e9todos","text":"<p>Extraer el c\u00f3digo de un m\u00e9todo en tantos otros como sea necesario para que cada uno tenga un tama\u00f1o m\u00e1ximo de unas 5 l\u00edneas aumenta la legibilidad y reduce el c\u00f3digo duplicado.</p> C\u00f3digo mejorable... extractmethod/UrlNormalizer.java<pre><code>public class UrlNormalizer {\n\n    public String normalize(String title) {\n        String url = \"\";\n        // First we trim whitespaces\n        url = title.trim();\n\n        // Remove special chars\n        String specialRemoved = \"\";\n        for (int i = 0; i &lt; url.length(); i++) {\n            if (url.charAt(i) != ',' &amp;&amp; url.charAt(i) != ':' \n                    &amp;&amp; url.charAt(i) != '.' &amp;&amp; url.charAt(i) != '?') {\n                specialRemoved += url.charAt(i);\n            }\n        }\n\n        url = specialRemoved;\n\n        // Replace white spaces with hyphens\n        String spacesReplaced = \"\";\n        for (int i = 0; i &lt; url.length(); i++) {\n            if (url.charAt(i) == ' ') {\n                spacesReplaced += \"-\";\n            } else {\n                spacesReplaced += url.charAt(i);\n            }\n        }\n        url = spacesReplaced;\n\n        // lowercase everything\n        url = url.toLowerCase();\n\n        return url;\n    }\n}\n</code></pre> <p>En IntelliJ IDEA, seleccionar el c\u00f3digo que nos interese extraer y <code>Refactor &gt; Extract Method</code>.</p> Refactorizaci\u00f3n <ul> <li>Se extrae a m\u00e9todos independientes cada fragmento de c\u00f3digo que resuelva una peque\u00f1a tarea.</li> </ul> extractmethod/refactored/UrlNormalizer.java<pre><code>public class UrlNormalizer {\n\n    public String normalize(String title) {\n        String url = trimSpaces(title);\n\n        url = removeSpecialChars(url);\n        url = replaceSpaces(url);\n        url = url.toLowerCase();\n\n        return url;\n    }\n\n    private String replaceSpaces(String url) {\n        String spacesReplaced = \"\";\n        for (int i = 0; i &lt; url.length(); i++) {\n            if (url.charAt(i) == ' ') {\n                spacesReplaced += \"-\";\n            } else {\n                spacesReplaced += url.charAt(i);\n            }\n        }\n        url = spacesReplaced;\n        return url;\n    }\n\n    private String removeSpecialChars(String url) {\n        String specialRemoved = \"\";\n        for (int i = 0; i &lt; url.length(); i++) {\n            if (url.charAt(i) != ',' &amp;&amp; url.charAt(i) != ':' \n                    &amp;&amp; url.charAt(i) != '.' &amp;&amp; url.charAt(i) != '?') {\n                specialRemoved += url.charAt(i);\n            }\n        }\n        url = specialRemoved;\n        return url;\n    }\n\n    private String trimSpaces(String title) {\n        String url = \"\";\n        url = title.trim();\n        return url;\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#introducir-metodos","title":"Introducir m\u00e9todos","text":"<p>Reintroducir el c\u00f3digo de un m\u00e9todo dentro del m\u00e9todo que lo llama para simplificar el c\u00f3digo al prescindir de m\u00e9todos demasiado simples u obvios. Hace el c\u00f3digo m\u00e1s legible, simplifica las clases y evita la proliferaci\u00f3n excesiva de m\u00e9todos.</p> C\u00f3digo mejorable... inlinemethod/UrlCleaner.java<pre><code>public class UrlCleaner {\n\n    public String clean(String title) {\n        String url = trimSpaces(title);\n\n        url = removeSpecialChars(url);\n        url = replaceSpaces(url);\n        url = url.toLowerCase();\n\n        return url;\n    }\n\n    private String replaceSpaces(String url) {\n        return url.replaceAll(\"[\\\\s]+\", \" \").replaceAll(\"[\\\\s]\", \"-\");\n    }\n\n    private String removeSpecialChars(String url) {\n        return url.replaceAll(\"[\\\\.\\\\:\\\\,\\\\?\\\\!\\\\_\\\\;]\", \"\");\n    }\n\n    private String trimSpaces(String url) {\n        return url.trim();\n    }\n}\n</code></pre> <p>En IntelliJ IDEA, seleccionar el m\u00e9todo/variable y <code>Refactor &gt; Rename</code>.</p> Refactorizaci\u00f3n <ul> <li>Se reducen todos los m\u00e9todos a un \u00fanico m\u00e9todo.</li> </ul> inlinemethod/refactored/UrlCleaner.java<pre><code>public class UrlCleaner {\n    public String clean (String title) {\n        return title.trim()\n                    .replaceAll(\"[\\\\.\\\\:\\\\,\\\\?\\\\!\\\\_\\\\;]\", \"\")  // Replaces special chars\n                    .replaceAll(\"[\\\\s]+\",\" \")                   // Replace duplicated spaces\n                    .replaceAll(\"[\\\\s]\",\"-\");                   // Replace spaces with hyphen\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#convertir-parametros-en-objetos","title":"Convertir par\u00e1metros en objetos","text":"<p>Sustituir una lista de par\u00e1metros de un m\u00e9todo por un objeto para simplificar su uso.</p> C\u00f3digo mejorable... <ul> <li>El m\u00e9todo <code>addItem</code> tiene demasiados par\u00e1metros.</li> </ul> parameterobject/Order.java<pre><code>public class Order {\n    private Hashtable&lt;String, Float&gt; items = new Hashtable&lt;String, Float&gt;();\n\n    public void addItem(Integer productID, String description, Integer quantity, Float price, Float discount) {\n        items.put(productID + \": \" + description, (quantity * price) - (quantity * price * discount));\n    }\n\n    public float calculateTotal() {\n        float total = 0;\n        Enumeration&lt;String&gt; keys = items.keys();\n\n        while (keys.hasMoreElements()) {\n            total = total + items.get(keys.nextElement());\n        }\n        return total;\n    }\n}\n</code></pre> <p>En IntelliJ IDEA, seleccionar el m\u00e9todo y <code>Refactor &gt; Introduce Parameter Object</code>.</p> Refactorizaci\u00f3n <ul> <li>Se crea una clase <code>OrderItem</code> que agrupa en sus atributos los antiguos par\u00e1metros.</li> </ul> parameterobject/refactored/Order.java<pre><code>public class Order {\n    private Hashtable&lt;String, Float&gt; items = new Hashtable&lt;String, Float&gt;();\n\n    public void addItem (OrderItem orderItem) {\n        items.put(orderItem.getProductID() + \": \" + orderItem.getDescription(), orderItem.totalItem());\n    }\n\n    public float calculateTotal () {\n        float total = 0;\n        Enumeration&lt;String&gt; keys = items.keys();\n\n        while(keys.hasMoreElements()) {\n            total  = total + items.get(keys.nextElement());\n        }\n\n        return total;\n    }\n}\n</code></pre> parameterobject/refactored/OrderItem.java<pre><code>public class OrderItem {\n    private int productID;\n    private String description;\n    private int quantity;\n    private float price;\n    private float discount;\n\n    public OrderItem(int productID, String description, int quantity, float price, float discount) {\n        this.productID = productID;\n        this.description = description;\n        this.quantity = quantity;\n        this.price = price;\n        this.discount = discount;\n    }\n\n    public float totalItem () {\n        return (quantity*price) - (quantity*price*discount);\n    }\n\n    public Integer getProductID() {\n        return productID;\n    }\n\n    public String getDescription() {\n        return description;\n    }        \n}\n</code></pre>"},{"location":"cleancode/refactoring.html#reemplazar-variable-temporal-con-consulta","title":"Reemplazar variable temporal con consulta","text":"<p>Extraer el valor de una variable temporal a un m\u00e9todo para reutilizar expresiones y producir un c\u00f3digo m\u00e1s legible.</p> C\u00f3digo mejorable... replacetempwithquery/Student.java<pre><code>public class Student {\n    private String name;\n    private boolean hasGoodAttitude;\n\n    public Student(String name, boolean hasGoodAttitude) {\n        this.name = name;\n        this.hasGoodAttitude = hasGoodAttitude;\n    }\n\n    public float calculateAverage(float homework, float exam) {\n        float mark = (homework + exam) / 2;\n\n        if (hasGoodAttitude) {\n            return mark + 1;\n        } else {\n            return mark;\n        }\n    }\n}\n</code></pre> <p>En IntelliJ IDEA, seleccionar la asignaci\u00f3n y <code>Refactor &gt; Extract Method</code>.</p> Refactorizaci\u00f3n <ul> <li>En el m\u00e9todo <code>mark</code> se extrae la operaci\u00f3n que se le asignaba a la variable temporal.</li> </ul> replacetempwithquery/refactored/Student.java<pre><code>public class StudentRefactored {\n    private String name;\n    private boolean hasGoodAttitude;\n\n    public Student(String name, boolean hasGoodAttitude) {\n        this.name = name;\n        this.hasGoodAttitude = hasGoodAttitude;\n    }\n\n    public float calculateAverage(float homework, float exam) {\n        if (hasGoodAttitude) {\n            return mark(homework, exam) + 1;\n        } else {\n            return mark(homework, exam);\n        }\n    }\n\n    private float mark(float homework, float exam) {\n        return (homework + exam) / 2;\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#introducir-variable-explicativa","title":"Introducir variable explicativa","text":"<p>Introducir variables para explicar una expresi\u00f3n compleja. Muy \u00fatil en condicionales.</p> C\u00f3digo mejorable... <ul> <li>La condici\u00f3n es muy compleja y dif\u00edcil de entender a simple vista.</li> </ul> explainingvariable/Customer.java<pre><code>class Customer {\n    private String name;\n    private int age;\n    private float salary;\n\n    public Customer(String name, int age, float salary) {\n        this.name = name;\n        this.age = age;\n        this.salary = salary;\n    }\n\n    public float applyDiscount (float totalAmount) {\n        if ((age &gt; 17 &amp;&amp; age &lt; 66) &amp;&amp; (salary - (salary * 0.2f)) &lt; 1000f &amp;&amp; totalAmount * 0.5 &lt; 100) {\n            return totalAmount * 0.9f;\n        } else {\n            return totalAmount;\n        }\n    }\n}\n</code></pre> <p>En IntelliJ IDEA, seleccionar la expresi\u00f3n a extraer y <code>Refactor &gt; Introduce Variable</code>.</p> Refactorizaci\u00f3n <ul> <li>Se extraen a variables cada una de las expresiones del condicional.</li> </ul> explainingvariable/refactored/Customer.java<pre><code>class Customer {\n    private String name;\n    private int age;\n    private float salary;\n\n    public Customer(String name, int age, float salary) {\n        this.name = name;\n        this.age = age;\n        this.salary = salary;\n    }\n\n    public float applyDiscount (float totalAmount) {\n        boolean isWorkingAge = (age &gt; 17 &amp;&amp; age &lt; 66);\n        boolean isLowSalary = (salary - (salary * 0.2f)) &lt; 1000f;\n        boolean isLittleAmount = totalAmount * 0.5 &lt; 100;\n\n        if (isWorkingAge &amp;&amp; isLowSalary &amp;&amp; isLittleAmount) {\n            return totalAmount * 0.9f;\n        } else {\n            return totalAmount;\n        }\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#separar-variable-temporal","title":"Separar variable temporal","text":"<p>Utilizar variables espec\u00edficas para cada prop\u00f3sito del m\u00e9todo en lugar de una temporal que acumule todas las operaciones. As\u00ed, cada variable tendr\u00e1 una responsabilidad \u00fanica y evitamos posibles efectos inesperados.</p> C\u00f3digo mejorable... <ul> <li>La variable <code>temp</code> se usa como caj\u00f3n de sastre para todos los c\u00e1lculos.</li> </ul> splittemporaryvariable/Invoice.java<pre><code>public class Invoice {\n\n    public float totalPrice (float price, float vat, float discount) {\n        float temp = 0;\n        temp = (vat * price) / 100;\n        System.out.println(\"Applied vat: \" + temp);\n\n        temp = price + temp;\n        System.out.println(\"Total with vat: \" + temp);\n\n        return temp - discount;\n    }\n}\n</code></pre> Refactorizaci\u00f3n <ul> <li>Se crean variables espec\u00edficas <code>appliedVat</code> y <code>priceWithVat</code> para cada operaci\u00f3n.</li> <li>Otro paso adidiconal ser\u00eda extraer a un m\u00e9todo espec\u00edfico la operaci\u00f3n de cada variable.</li> </ul> splittemporaryvariable/refactored/Invoice.java<pre><code>public class Invoice {\n\n    public float totalPrice (float price, float vat, float discount) {\n        float appliedVat = (vat * 100) / price;     \n        System.out.println(\"Applied vat: \" + appliedVat);\n\n        float priceWithVat = price + appliedVat;\n        System.out.println(\"Total: \" + priceWithVat);\n\n        return priceWithVat - discount;\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#eliminar-asignaciones-a-parametros","title":"Eliminar asignaciones a par\u00e1metros","text":"<p>Evitar que se asignen valores a un par\u00e1metro dentro de un m\u00e9todo utilizando una variable local. Se evitan efectos inesperados y as\u00ed cada par\u00e1metro tiene un prop\u00f3sito \u00fanico.</p> C\u00f3digo mejorable... <ul> <li>Se modifica los valores de los par\u00e1metros <code>examMark</code> y <code>homeworkMark</code> dentro del m\u00e9todo.</li> </ul> <p>``` java title=\"removeparameterassignment/Student.java\" hl_lines=4 8\" public class Student {     public float evaluateTerm(float homeworkMark, float examMark, float attitude) {         if (examMark &lt; 5) {             examMark = 1;         }</p> <pre><code>    if (homeworkMark &lt; 4) {\n        homeworkMark = 1;\n    }\n    return (homeworkMark + examMark) / 2 + attitude;\n}\n</code></pre> <p>} ```</p> Refactorizaci\u00f3n <ul> <li>Se crea la variable local <code>finalMark</code> para no modificar los par\u00e1metros.</li> </ul> removeparameterassignment/refactored/Student.java<pre><code>public class Student {\n    public float evaluateTerm(float homeworkMark, float examMark, float attitude) {\n        float finalMark = 0;\n        if (examMark &lt; 5) {\n            finalMark = 1;\n        } else {\n            finalMark = examMark;\n        }\n\n        if (homeworkMark &lt; 4) {\n            finalMark = finalMark + 1;\n        } else {\n            finalMark = finalMark + homeworkMark;\n        }\n        return (finalMark) / 2 + attitude;\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#reemplazar-metodo-con-un-objeto","title":"Reemplazar m\u00e9todo con un objeto","text":"<p>Extraer un m\u00e9todo complejo o extenso a una clase aparte para simplificarlo.</p> C\u00f3digo mejorable... <ul> <li>El m\u00e9todo <code>applyDiscount</code> es demasiado extenso y se extraer\u00e1 a una clase.</li> </ul> replacemethodwithmethodobject/Customer.java<pre><code>public class Customer {\n\n    private boolean isVip;\n    private boolean isSpecial;\n    private int type;\n\n    public static final int NORMAL = 0;\n    public static final int SPECIAL = 1;\n    public static final int VIP = 2;\n\n    public Customer(boolean isVip, boolean isSpecial, int type) {\n        this.isVip = isVip;\n        this.isSpecial = isSpecial;\n        this.type = type;\n    }\n\n    public double applyDiscount(double price, double discount) {\n        double finalPrice;\n        double appliedVat;\n\n        switch (getType()) {\n        case Customer.NORMAL:\n            appliedVat = 1.21f;\n            break;\n        case Customer.SPECIAL:\n            appliedVat = 1.15f;\n            break;\n        case Customer.VIP:\n            appliedVat = 1.04f;\n            break;\n        default:\n            appliedVat = 1.21f;\n            break;\n        }\n\n        if (price &gt; 50 &amp;&amp; isVip()) {\n            finalPrice = price * 0.5;\n        } else if (price &gt; 10 &amp;&amp; isSpecial()) {\n            finalPrice = price * 0.1;\n        } else {\n            finalPrice = price;\n        }\n\n        return finalPrice * appliedVat - discount;\n    }\n\n    public int getType() {\n        return type;\n    }\n\n    public boolean isVip() {\n        return isVip;\n    }\n\n    public boolean isSpecial() {\n        return isSpecial;\n    }\n}\n</code></pre> Refactorizaci\u00f3n <ul> <li>Se ha creado la clase <code>DiscountCalculator</code> con el m\u00e9todo <code>applyDiscount</code>, el que a su vez, se ha extraido a m\u00e9todos.</li> <li>Mejora adicional: Sustituir el <code>switch</code> por una jerarqu\u00eda de clases en la que la llamada al tipo de cliente se resuelva mediante polimorfismo.</li> </ul> replacemethodwithmethodobject/refactored/DiscountCalculator.java<pre><code>public class DiscountCalculator {\n    private double finalPrice;\n    private double appliedVat;\n    private double price;\n    private Customer customer;\n    private double discount;\n\n    public DiscountCalculator(double price, Customer customer, double discount) {\n        finalPrice = 0;\n        appliedVat = 0;\n        this.price = price;\n        this.customer = customer;\n        this.discount = discount;\n    }\n\n    public double applyDiscount() {\n        return calculatePrice() * calculateVat() - discount;\n    }\n\n    private double calculateVat() {\n        switch (customer.getType()) {\n            case Customer.NORMAL:\n                return 1.21f;\n            case Customer.SPECIAL:\n                return 1.15f;\n            case Customer.VIP:\n                return 1.04f;\n            default:\n                return 1.21f;\n        }\n    }\n\n    private double calculatePrice() {\n        if (price &gt; 50 &amp;&amp; customer.isVip()) {\n            finalPrice = price * 0.5;\n        } else if (price &gt; 10 &amp;&amp; customer.isSpecial()) {\n            finalPrice = price * 0.1;\n        } else {\n            finalPrice = price;\n        }\n\n        return finalPrice;\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#descomponer-condicional","title":"Descomponer condicional","text":"<p>Sustituir expresiones complejas de un condicional por una llamada a un m\u00e9todo. As\u00ed, se reducen los m\u00e9todos y se crean condiciones reutilizables m\u00e1s expresivas. </p> <p>Similar a la refactorizaci\u00f3n vista de Introducir variable explicativa, pero con un m\u00e9todo.</p> C\u00f3digo mejorable... decomposeconditional/Invoice.java<pre><code>public class Invoice {\n    private Customer customer;\n\n    public Invoice (Customer customer) {\n        this.customer = customer;\n    }\n\n    public float calculatePayment (float price, float discount, float vat) {\n        float payment = 0;\n\n        if (customer.getAge() &lt; 18 || customer.getAge() &gt; 65 ) {\n            payment = price * discount * vat;\n        }else {\n            payment = price * vat;\n        }\n\n        return payment;\n    }\n}\n</code></pre> <p>En IntelliJ IDEA, seleccionar la expresi\u00f3n condicional y <code>Refactor &gt; Extract Method</code>.</p> Refactorizaci\u00f3n <ul> <li>Se crea el m\u00e9todo <code>canApplyDiscount</code> para sustituir las expresiones complejas anteriores.</li> </ul> decomposeconditional/refactored/Invoice.java<pre><code>public class Invoice {\n\n    private Customer customer;\n\n    public Invoice (Customer customer) {\n        this.customer = customer;\n    }\n\n    public float calculatePayment (float price, float discount, float vat) {\n        float payment = 0;\n\n        if (canApplyDiscount() ) {\n            payment = price * discount * vat;\n        }else {\n            payment = price * vat;\n        }\n\n        return payment;\n    }\n\n    private boolean canApplyDiscount() {\n        return customer.getAge() &lt; 18 || customer.getAge() &gt; 65;\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#consolidar-expresion-condicional","title":"Consolidar expresi\u00f3n condicional","text":"<p>Agrupar los bloques condicionales que comparten el mismo c\u00f3digo reduciendo el tama\u00f1o de los m\u00e9todos y evitando c\u00f3digo duplicado.</p> C\u00f3digo mejorable... <ul> <li>Varios bloques condicionales tienen exactamente el mismo c\u00f3digo.</li> </ul> consolidateconditional/Invoice.java<pre><code>public class Invoice {\n\n    private Customer customer;\n    private int year;\n\n    public Invoice(Customer customer, int year) {\n        this.customer = customer;\n        this.year = year;\n    }\n\n    public float calculateTotal(float subtotal, float vat) {\n        if (customer.getAge() &lt; 18)\n            return 0;\n        if (new GregorianCalendar().get(Calendar.YEAR) &gt; year)\n            return 0;\n        if (subtotal &lt; 0.5f)\n            return 0;\n\n        return subtotal * vat;\n    }\n}\n</code></pre> Refactorizaci\u00f3n <ul> <li>El c\u00f3digo compartido se agrupa bajo una misma condici\u00f3n m\u00faltiple.</li> <li>Se aplica adem\u00e1s la refactorizaci\u00f3n anterior Descomponer condicional para extraer a un m\u00e9todo dicho condicional.</li> </ul> consolidateconditional/refactored/Invoice.java<pre><code>    public class Invoice {\n\n    private Customer customer;\n    private int year;\n\n    public Invoice(Customer customer, int year) {\n        this.customer = customer;\n        this.year = year;\n    }\n\n    public float calculateTotal(float subtotal, float vat) {\n        if (isUselessToCharge(subtotal)) {\n            return 0;\n        } else {\n            return subtotal * vat;\n        }\n    }\n\n    private boolean isUselessToCharge(float subtotal) {\n        return (customer.getAge() &lt; 18) || (new Date().getYear() &gt; year) || (subtotal &lt; 0.5f);\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#consolidar-fragmentos-de-condicional-duplicados","title":"Consolidar fragmentos de condicional duplicados","text":"<p>Extraer c\u00f3digo repetido en diferentes bloques de condicionales para evitar la duplicidad.</p> C\u00f3digo mejorable... <ul> <li>Algunas operaciones de los bloques del condicional son exactamente iguales y se podr\u00edan dejar fuera de los condicionales para que se apliquen en ambos casos.</li> </ul> consolidateduplicateconditional/Invoice.java<pre><code>public class Invoice {\n\n    private Customer customer;\n    private float price;\n    private int qty;\n\n    public Invoice (Customer customer, float price, int qty) {\n        this.customer = customer;\n        this.price = price;\n        this.qty = qty;\n    }\n\n    public float calculateTotal (float vat, float discount) {\n        float subtotal = 0;\n        if (customer.isVip()) {\n            subtotal = (price * qty) - discount;\n            subtotal = subtotal * (1 + (vat/100));\n            return subtotal;\n        } else {\n            subtotal = (price * qty);\n            subtotal = subtotal * (1 + (vat/100));\n            return subtotal;\n        }\n    }\n}\n</code></pre> <p>En IntelliJ IDEA, seleccionar el m\u00e9todo/variable y <code>Refactor &gt; Rename</code>.</p> Refactorizaci\u00f3n <ul> <li>La operaci\u00f3n duplicada se extrae fuera de los condiciones, aplic\u00e1ndola as\u00ed en todos los casos.</li> </ul> consolidateduplicateconditional/refactored/Invoice.java<pre><code>public class Invoice {\n\n    private Customer customer;\n    private float price;\n    private int qty;\n\n    public Invoice (Customer customer, float price, int qty) {\n        this.customer = customer;\n        this.price = price;\n        this.qty = qty;\n    }\n\n    public float calculateTotal (float vat, float discount) {\n        float subtotal = 0;\n        if (customer.isVip()) {\n            subtotal = (price * qty) - discount;\n        } else {\n            subtotal = (price * qty);\n        }\n        return subtotal * (1 + (vat/100));\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#eliminar-bandera-de-control","title":"Eliminar bandera de control","text":"<p>Eliminar variables que se utilizan para controlar el flujo del programa y en su lugar utilizar break, continue o return para conseguir el mismo prop\u00f3sito.</p> C\u00f3digo mejorable... <ul> <li>Existe una variable bandera <code>found</code> que ser\u00eda interesante eliminar.</li> </ul> removecontrolflag/Friends.java<pre><code>public class Friends {\n    private String[] friends;\n\n    public Friends (String[] friends) {\n        this.friends = friends;\n    }\n\n    public int indexOf (String friend) {\n        boolean found = false; // Bandera\n        int i = 0;\n\n        while (i &lt; friends.length &amp;&amp; !found ) { \n            if (friends[i].equals(friend)) {\n                found = true;\n            }\n            i++;\n        }\n\n        if (found) {\n            return (i-1);\n        } else {\n            return -1;\n        }\n    }\n}\n</code></pre> <p>En IntelliJ IDEA, seleccionar el m\u00e9todo/variable y <code>Refactor &gt; Rename</code>.</p> Refactorizaci\u00f3n <ul> <li>Se podr\u00eda sustituir la variable bandara con un <code>break</code> para salir del bucle, pero mucho mejor es hacerlo con el <code>return</code> devolviendo la posici\u00f3n directamente. </li> </ul> packet/removecontrolflag/Friends.java<pre><code>public class Friends {\n    private String[] friends;\n\n    public Friends (String[] friends) {\n        this.friends = friends;\n    }\n\n    public int indexOf (String friend) {\n        for (int i = 0; i&lt; friends.length; i++) \n            if (friends[i].equals(friend)) \n                return i;\n\n        return -1;\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#reemplazar-condicionales-anidados-con-clausulas-guard","title":"Reemplazar condicionales anidados con cla\u00fasulas guard","text":"<p>Simplificar los condicionales anidados llegando idealmente a un \u00fanico nivel para facilitar su legibilidad.</p> <p>Una cl\u00e1usula guard (tambi\u00e9n llamada \"early return\" o \"return early\") es una t\u00e9cnica de programaci\u00f3n que permite evitar la anidaci\u00f3n excesiva de estructuras condicionales (if-else) en el c\u00f3digo. Sirve para hacer que el c\u00f3digo sea m\u00e1s legible y f\u00e1cil de entender, al \"filtrar\" las condiciones al principio de una funci\u00f3n y retornar antes si alguna condici\u00f3n no se cumple.</p> C\u00f3digo mejorable... <ul> <li>Hay demasiados niveles if-else anidados que dificultan su comprensi\u00f3n.</li> </ul> replacenestedconditionalguardclauses/Flight.java<pre><code>public class Flight {\n\n    private static final float CHILDREN_DISCOUNT = 0.9f;\n    private static final float UNEMPLOYED_DISCOUNT = 0.8f;\n    private static final int BASE_PRICE = 20;\n    private int distance;\n\n    public Flight (int distance) {\n        this.distance = distance;\n    }\n\n    public float priceForPassenger (Passenger passenger) {\n        float price = 0;\n        if (passenger.isAChild()) {\n            price = getChildDiscount();\n        } else {\n            if (passenger.isUnemployed()) {\n                price = getUnemployedDiscount();\n            } else {\n                if (isChristmas()) {\n                    price = 0;\n                } else {\n                    price = getNormalPrice();\n                }\n            }\n        }\n        return price;\n    }\n\n    private float getUnemployedDiscount() {\n        return BASE_PRICE * distance * UNEMPLOYED_DISCOUNT;\n    }\n\n    private float getNormalPrice() {\n        return BASE_PRICE * distance;\n    }\n\n    private boolean isChristmas() {\n        return false;\n    }\n\n    private float getChildDiscount() {\n        return BASE_PRICE * distance * CHILDREN_DISCOUNT;\n    }\n}\n</code></pre> Refactorizaci\u00f3n <ul> <li>Se eliminan los if-else anidados dej\u00e1ndolos en un \u00fanico nivel.</li> </ul> replacenestedconditionalguardclauses/refactored/Flight.java<pre><code>public class Flight {\n\n    private static final float CHILDREN_DISCOUNT = 0.9f;\n    private static final float UNEMPLOYED_DISCOUNT = 0.8f;\n    private static final int BASE_PRICE = 20;\n    private int distance;\n\n    public Flight (int distance) {\n        this.distance = distance;\n    }\n\n    public float priceForPassenger (Passenger passenger) {\n        if (passenger.isAChild()) return getChildDiscount();\n        if (passenger.isUnemployed()) return getUnemployedDiscount();\n        if (isChristmas()) return 0;\n        return getNormalPrice();\n\n    }\n\n    private float getUnemployedDiscount() {\n        return BASE_PRICE * distance * UNEMPLOYED_DISCOUNT;\n    }\n\n    private float getNormalPrice() {\n        return BASE_PRICE * distance;\n    }\n\n    private boolean isChristmas() {\n        return false;\n    }\n\n    private float getChildDiscount() {\n        return BASE_PRICE * distance * CHILDREN_DISCOUNT;\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#reemplazar-condicional-con-polimorfismo","title":"Reemplazar condicional con polimorfismo","text":"<p>Sustituir las expresiones condicionales (normalmente un <code>switch</code>) por una jerarqu\u00eda de clases en la que la llamada al tipo espec\u00edfico se resuelva mediante polimorfismo. </p> <p>De esta forma se mejora el mantenimiento de la aplicaci\u00f3n al ser m\u00e1s sencillo a\u00f1adir nuevos casos en un futuro sin necesidad de duplicar c\u00f3digo.</p> C\u00f3digo mejorable... <ul> <li>El <code>switch</code> se har\u00eda muy enrevesado si se tienen muchos tipos de veh\u00edculos.</li> </ul> replaceconditionalwithpolymorphism/Vehicle.java<pre><code>public class Vehicle {\n\n    private static final int CAR = 0;\n    private static final int BIKE = 1;\n    private static final int PLANE = 2;\n\n    private int vehicleType;\n    private int speed;\n    private int acceleration;\n\n    public Vehicle(int vehicleType, int speed, int acceleration) {\n        this.vehicleType = vehicleType;\n        this.speed = speed;\n        this.acceleration = acceleration;\n    }\n\n    public int move () {\n        int result = 0;\n        switch (vehicleType) {\n            case CAR:\n                result = speed * acceleration * 5;\n                break;\n            case BIKE:\n                result = speed * 10;\n                break;\n            case PLANE:\n                result = acceleration * 2;\n                break;\n        }\n\n        return result;\n    }\n}\n</code></pre> Refactorizaci\u00f3n <ul> <li>Se crea una clase abstracta <code>Vehiculo</code> con su m\u00e9todo abstracto <code>move</code>.</li> <li>Se crean clases hijas <code>Bike</code>, <code>Car</code> y <code>Plane</code> que definen dicho m\u00e9todo <code>move</code> al que se llamar\u00e1 directamente si necesidad del <code>switch</code>.</li> </ul> replaceconditionalwithpolymorphism/refactored/Vehicle.java<pre><code>public abstract class Vehicle {\n    protected int vehicleType;\n    protected int speed;\n    protected int acceleration;\n\n    public Vehicle(int vehicleType, int speed, int acceleration) {\n        this.vehicleType = vehicleType;\n        this.speed = speed;\n        this.acceleration = acceleration;\n    }\n\n    public abstract int move ();\n}\n</code></pre> replaceconditionalwithpolymorphism/refactored/Bike.java<pre><code>public class Bike extends Vehicle { \n    public Bike(int vehicleType, int speed, int acceleration) {\n        super(vehicleType, speed, acceleration);\n    }\n\n    @Override\n    public int move () { return speed * 10; }\n}\n</code></pre> replaceconditionalwithpolymorphism/refactored/Car.java<pre><code>public class Car extends Vehicle {\n    public Car(int vehicleType, int speed, int acceleration) {\n        super(vehicleType, speed, acceleration);\n    }\n\n    @Override\n    public int move () { return speed * acceleration * 5; }\n}\n</code></pre> replaceconditionalwithpolymorphism/refactored/Plane.java<pre><code>public class Plane extends Vehicle {\n    public Plane(int vehicleType, int speed, int acceleration) {\n        super(vehicleType, speed, acceleration);\n    }\n\n    @Override\n    public int move () { return  acceleration * 2; }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#introducir-objeto-nulo","title":"Introducir objeto nulo","text":"<p>Utilizar un objeto que representa el valor <code>null</code> de algo evitando realizar comparaciones directamente con <code>null</code>, lo que no suele ser muy recomendable porque puede provocar errores inesperados.</p> C\u00f3digo mejorable... <ul> <li>Para el ataque del guerrero se comprueba que tenga un arma (no sea <code>null</code>) para obtener el da\u00f1o que hace y sumarlo.</li> </ul> introducenullobject/Weapon.java<pre><code>public class Weapon {\n    private int damage;\n\n    public Weapon(int damage) {\n        this.damage = damage;\n    }\n\n    public int getDamage() {\n        return damage + new Random().nextInt(3);\n    }\n}\n</code></pre> introducenullobject/Warrior.java<pre><code>public class Warrior {\n    private Weapon weapon;\n\n    public Warrior(Weapon weapon) {\n        this.weapon = weapon;\n    }\n\n    public int attack() {\n        int damage = 0;\n        if (weapon == null) {\n            damage = 2;\n        } else {\n            damage = 2 + weapon.getDamage();\n        }\n        return damage;\n    }\n}\n</code></pre> Refactorizaci\u00f3n <ul> <li>Se crea la clase <code>NullWeapon</code> que hereda de <code>Weapon</code> y representa el da\u00f1o que hace no tener un arma equipada, evitando as\u00ed la comparaci\u00f3in con <code>null</code> anterior.</li> </ul> introducenullobject/refactored/Warrior.java<pre><code>public class NullWeapon extends Weapon {\n    public NullWeapon(int damage) {\n        super(damage);\n    }\n\n    @Override\n    public int getDamage() {\n        return 0;\n    }\n}\n</code></pre> introducenullobject/Warrior.java<pre><code>public class Warrior {\n    private Weapon weapon;\n\n    public Warrior(Weapon weapon) {\n        this.weapon = weapon;\n    }\n\n    public int attack() {\n        return 2 + weapon.getDamage();\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#separar-consulta-de-modificacion","title":"Separar consulta de modificaci\u00f3n","text":"<p>Evitar que un mismo m\u00e9todo haga una consulta de datos y relice modificaciones. Mejor separar en varios m\u00e9todos para evitar que un m\u00e9todo de consulta tenga resultados inesperados. Un m\u00e9todo tiene que tener un \u00fanico prop\u00f3sito.</p> C\u00f3digo mejorable... <ul> <li>El m\u00e9todo <code>initVehicleAndGetType</code> modifica los atributos <code>horsePower</code> y <code>type</code>. Y adem\u00e1s devuelve <code>type</code>. Un m\u00e9todo s\u00f3lo deber\u00eda hacer una \u00fanica tarea, en este caso o modificar, o bien obtener valores.</li> </ul> separatequerymodify/Vehicle.java<pre><code>public class Vehicle {\n    private int horsePower;\n    private String type;\n\n    public Vehicle(int power) {\n        initVehicleAndGetType(power);\n    }\n\n    private String initVehicleAndGetType(int power) {\n        horsePower = power;\n\n        if (power &gt;= 10) {\n            type = \"Truck\";\n        } else if (power &gt; 5 &amp;&amp; power &lt; 10) {\n            type = \"Car\";\n        } else {\n            type = \"Bike\";\n        }\n\n        return type;\n    }\n\n    public int getHorsePower() {\n        return horsePower;\n    }\n\n    public String getType() {\n        return type;\n    }\n}\n</code></pre> Refactorizaci\u00f3n <ul> <li>Se modifica el m\u00e9todo de inicio <code>init</code> estableciendo en m\u00e9todos separados los atributos.</li> <li>Se hacen los getters correspondientes para obtener el valor de los atributos.</li> </ul> separatequerymodify/refactored/Vehicle.java<pre><code>public class Vehicle {\n    private int horsePower;\n    private String type;\n\n    public Vehicle(int power) {\n        init(power);\n    }\n\n    private void init(int power) {\n        setPower(power);\n        setType();\n    }\n\n    private void setPower(int power) {\n        horsePower = power;\n    }\n\n    private void setType() {\n        if (horsePower &gt;= 10) {\n            type = \"Truck\";\n        } else if (horsePower &gt; 5 &amp;&amp; horsePower &lt; 10) {\n            type = \"Car\";\n        } else {\n            type = \"Bike\";\n        }\n    }\n\n    public int getHorsePower() {\n        return horsePower;\n    }\n\n    public String getType() {\n        return type;\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#parametrizar-metodo","title":"Parametrizar m\u00e9todo","text":"<p>Unificar en un m\u00e9todo varios m\u00e9todos en los que s\u00f3lo cambia un valor para evitar c\u00f3digo duplicado. Se hace, a\u00f1adiendo al m\u00e9todo un par\u00e1metro (el valor que cambia).</p> C\u00f3digo mejorable... <ul> <li>Hay varios m\u00e9todos que hacen lo mismo cambiando un \u00fanico valor.</li> </ul> parametrizemethod/Invoice.java<pre><code>public class Invoice {\n    private float subtotal;\n    private Customer customer;\n\n    public Invoice(float subtotal, Customer customer) {\n        this.subtotal = subtotal;\n        this.customer = customer;\n    }\n\n    public float charge() {\n        if (customer.getAge() &lt; 18) {\n            return chargeWithUnderageDiscount();\n        } else if (customer.payInCash()) {\n            return chargeWithCashDiscount();\n        } else {\n            return chargeNormal();\n        }\n    }\n\n    private float chargeWithUnderageDiscount() {\n        float total = subtotal * 0.5f;\n        return total;\n    }\n\n    private float chargeWithCashDiscount() {\n        float total = subtotal * 0.8f;\n        return total;\n    }\n\n    private float chargeNormal() {\n        return subtotal;\n    }\n}\n</code></pre> Refactorizaci\u00f3n <ul> <li>Se a\u00f1ade como par\u00e1metro del m\u00e9todo el valor que cambia unificando todo en un \u00fanico m\u00e9todo.</li> </ul> parametrizemethod/refactored/Invoice.java<pre><code>public class Invoice {\n    private float subtotal;\n    private Customer customer;\n\n    public Invoice(float subtotal, Customer customer) {\n        this.subtotal = subtotal;\n        this.customer = customer;\n    }\n\n    public float charge() {\n        if (customer.getAge() &lt; 18) {\n            return charge(0.5f);\n        } else if (customer.payInCash()) {\n            return charge(0.8f);\n        } else {\n            return charge();\n        }\n    }\n\n    public float charge (float discount) {\n        return subtotal * discount;\n        }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#reemplazar-parametro-con-metodo-explicito","title":"Reemplazar par\u00e1metro con m\u00e9todo expl\u00edcito","text":"<p>La contraria a la refactorizaci\u00f3n anterior. En este caso reemplazamos un par\u00e1metro por m\u00e9todos espec\u00edficos. Se suele utilizar en m\u00e9todos que han crecido mucho o realizan varias acciones.</p> C\u00f3digo mejorable... <ul> <li>El m\u00e9todo <code>initVehicle</code> ha crecido mucho con condicionales dentro para modificar varios atributos.</li> </ul> replaceparameterwitexplicitmethod/Vehicle.java<pre><code>public class Vehicle {\n\n    private int acceleration;\n    private int speed;\n\n    public Vehicle(int acceleration, int speed) {\n        this.acceleration = acceleration;\n        this.speed = speed;\n    }\n\n    public void initVehicle (int type, int value) {\n        if (type == 1) {\n            acceleration = value;\n            return;\n        }\n\n        if (type == 2 || type == 3)  {\n            speed = value;\n            return;\n        }\n    }\n\n    public int getAcceleration() {\n        return acceleration;\n    }\n\n    public int getSpeed() {\n        return speed;\n    }\n}\n</code></pre> Refactorizaci\u00f3n <ul> <li>El m\u00e9todo <code>initVehicle</code> se ha separado en los setters correspondientes a los atributos, simplificando as\u00ed el c\u00f3digo.</li> </ul> replaceparameterwitexplicitmethod/refactored/Vehicle.java<pre><code>public class Vehicle {\n\n    private int acceleration;\n    private int speed;\n\n    public Vehicle(int acceleration, int speed) {\n        this.acceleration = acceleration;\n        this.speed = speed;\n    }\n\n    public int getAcceleration() {\n        return acceleration;\n    }\n\n    public int getSpeed() {\n        return speed;\n    }\n\n    public void setAcceleration(int acceleration) {\n        this.acceleration = acceleration;\n    }\n\n    public void setSpeed(int speed) {\n        this.speed = speed;\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#sustituir-algoritmo","title":"Sustituir algoritmo","text":"<p>Optimiza el c\u00f3digo mejorando el rendimiento de un m\u00e9todo que no sea eficiente y por ejemplo genere un cuello de botella.</p> C\u00f3digo mejorable... <ul> <li>La variable <code>vatType</code> se comprueba con cada uno de los casos, lo que no es muy eficiente si se tiene que hacer para muchos datos.</li> </ul> <p>``` java title=\"susbtitutealtorithm/Order.java\" hl_lines=\"\" public class Order {     public float applyVAT (int vatType) {         float result = 0;</p> <pre><code>    switch (vatType) {\n        case 1:\n            result = 1.04f;\n            break;\n        case 2:\n            result = 1.18f;\n            break;\n        case 3:\n            result = 1.21f;\n            break;\n        default:\n            result = -1;\n            break;\n}\nreturn result;\n}\n</code></pre> <p>} ```</p> Refactorizaci\u00f3n <ul> <li>Se ha sustituido cada caso del switch por una entrada del array, de tal forma que el valor de cada caso coincide con el \u00edndice del array. As\u00ed se puede devolver el valor que le corresponda de forma directa.</li> </ul> susbtitutealtorithm/refactored/Order.java<pre><code>public class Order {\n    public float applyVAT (int vatType) {\n        float result[] = {-1, 1.04f, 1.18f, 1.21f};\n\n        if (vatType &gt; 0 &amp;&amp; vatType &lt; result.length) {\n            return result[vatType];\n        }\n        return -1;\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#extraer-clase","title":"Extraer clase","text":"<p>Sacar parte del contenido de una clase a otra porque la clase original tenga demasiadas responsabilidades.</p> C\u00f3digo mejorable... <ul> <li>Los campos relacionados con la tarjeta de cr\u00e9dito se pueden extraer a otra clase.</li> </ul> extractclass/Customer.java<pre><code>public class Customer {\n    private String name;\n    private String dni;\n    private String creditCard;\n    private Date creditCardDate;\n    private int creditCardControlNumber;\n\n    public Customer(String name, String dni) {\n        this.name = name;\n        this.dni = dni;\n    }\n\n    public boolean isCardExpired () {\n        return creditCardDate.before(new Date());\n    }\n\n    public boolean isValid () {\n        boolean result = false;\n        // Some code here...\n        return result;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDni() {\n        return dni;\n    }\n\n    public void setDni(String dni) {\n        this.dni = dni;\n    }\n\n    public String getCreditCard() {\n        return creditCard;\n    }\n\n    public void setCreditCard(String creditCard) {\n        this.creditCard = creditCard;\n    }\n\n    public Date getCreditCardDate() {\n        return creditCardDate;\n    }\n\n    public void setCreditCardDate(Date creditCardDate) {\n        this.creditCardDate = creditCardDate;\n    }\n\n    public int getCreditCardControlNumber() {\n        return creditCardControlNumber;\n    }\n\n    public void setCreditCardControlNumber(int creditCardControlNumber) {\n        this.creditCardControlNumber = creditCardControlNumber;\n    }\n\n}\n</code></pre> <p>En IntelliJ IDEA, seleccionar el m\u00e9todo/variable y <code>Refactor &gt; Rename</code>.</p> Refactorizaci\u00f3n <ul> <li>Se crea la clase <code>CreditCard</code> con sus atributos y m\u00e9todos.</li> </ul> <p>``` java title=\"extractclass/refactored/Customer.java\" hl_lines=\"\" public class Customer {     private String name;     private String dni;     private CreditCard creditCard;</p> <pre><code>public Customer(String name, String dni) {\n    this.name = name;\n    this.dni = dni;\n}\n\npublic String getName() {\n    return name;\n}\n\npublic void setName(String name) {\n    this.name = name;\n}\n\npublic String getDni() {\n    return dni;\n}\n\npublic void setDni(String dni) {\n    this.dni = dni;\n}\n</code></pre> <p>} <code></code> java title=\"extractclass/refactored/CreditCard.java\" hl_lines=\"\" public class CreditCard {     private String creditCard;     private Date creditCardDate;     private int creditCardControlNumber;      public CreditCard(String creditCard, Date creditCardDate, int creditCardControlNumber) {         this.creditCard = creditCard;         this.creditCardDate = creditCardDate;         this.creditCardControlNumber = creditCardControlNumber;     }      public boolean isCardExpired () {         return creditCardDate.before(new Date());     }      public boolean isValid () {         boolean result = false;         // Some code here...         return result;     }      public Date getCreditCardDate() {         return creditCardDate;     }      public void setCreditCardDate(Date creditCardDate) {         this.creditCardDate = creditCardDate;     }      public int getCreditCardControlNumber() {         return creditCardControlNumber;     }      public void setCreditCardControlNumber(int creditCardControlNumber) {         this.creditCardControlNumber = creditCardControlNumber;     } } ```</p>"},{"location":"cleancode/refactoring.html#clase-en-linea","title":"Clase en l\u00ednea","text":"<p>Refactorizaci\u00f3n contraria a la anterior. Introducir los atributos y m\u00e9todos de una clase que por s\u00ed sola no tenga mucho sentido en otra clase.</p> C\u00f3digo mejorable... <ul> <li>La clase <code>Sex</code> s\u00f3lo tiene un atributo y no define ning\u00fan comportamiento.</li> </ul> <p>``` java title=\"inlineclass/Person.java\" hl_lines=\"\" public class Person {     private String name;     private Date birth;     private Sex sex;</p> <pre><code>public Person(String name, Date birth, int sexCode) {\n    this.name = name;\n    this.birth = birth;\n    this.sex = new Sex(sexCode);\n}\n\npublic String getName() {\n    return name;\n}\n\npublic void setName(String name) {\n    this.name = name;\n}\n\npublic Date getBirth() {\n    return birth;\n}\n\npublic void setBirth(Date birth) {\n    this.birth = birth;\n}\n\npublic Sex getSex() {\n    return sex;\n}\n\npublic void setSex(Sex sex) {\n    this.sex = sex;\n}\n\n@Override\npublic String toString() {\n    return \"Person [name=\" + name + \", sex=\" + sex + \"]\";\n}\n</code></pre> <p>} <code></code> java title=\"inlineclass/Person.java\" hl_lines=\"\" public class Sex {     public static final int MALE = 0;     public static final int FEMALE = 1;     private int sex;      public Sex (int sex) {         this.sex = sex;     }      public int getSex () {         return sex;     }      @Override     public String toString() {         return Integer.toString(sex);     } } ```</p> Refactorizaci\u00f3n <ul> <li>Se introducen los atributos y m\u00e9todos de <code>Sex</code> dentro de <code>Person</code>.</li> </ul> <p>``` java title=\"inlineclass/refactored/Person.java\" hl_lines=\"\" public class Person {     private String name;     private Date birth;     public static final int MALE = 0;     public static final int FEMALE = 1;     private int sex;</p> <pre><code>public Person(String name, Date birth, int sexCode) {\n    this.name = name;\n    this.birth = birth;\n    this.sex = sexCode;\n}\n\npublic String getName() {\n    return name;\n}\n\npublic void setName(String name) {\n    this.name = name;\n}\n\npublic Date getBirth() {\n    return birth;\n}\n\npublic void setBirth(Date birth) {\n    this.birth = birth;\n}\n\npublic int getSex() {\n    return sex;\n}\n\npublic void setSex(int sex) {\n    this.sex = sex;\n}\n\n@Override\npublic String toString() {\n    return \"Person [name=\" + name + \", sex=\" + sex + \"]\";\n}\n</code></pre> <p>} ```</p>"},{"location":"cleancode/refactoring.html#ocultar-delegar","title":"Ocultar Delegar","text":"<p>Evitar que un cliente (m\u00e9todo principal por ejemplo) pueda acceder a una clase delegada a trav\u00e9s de clases intermedias.</p> C\u00f3digo mejorable... <ul> <li>Desde la clase <code>Main</code> se accede al dado <code>Die</code> que depende de <code>Player</code>.</li> </ul> hidedelegate/Main.java<pre><code>public class Main {\n    private Player player;\n    private Die die;\n\n    public Main () {\n        init();\n    }\n\n    private void init () {\n        player = new Player();\n        die = player.getDie();\n    }\n\n    public int roll () {\n        return die.roll();\n    }\n}\n</code></pre> <p>``` java title=\"hidedelegate/Player.java\" hl_lines=\"\" public class Player {     private Die die;</p> <pre><code>public Player () {\n    this.die = new Die();\n}\n\npublic int roll () {\n    return die.roll();\n}\n\npublic Die getDie() {\n    return die;\n}\n</code></pre> <p>} <code></code> java title=\"hidedelegate/Die.java\" hl_lines=\"\" public class Die {     private Random random = new Random();      public int roll() {         return random.nextInt(6) + 1;     } } ```</p> Refactorizaci\u00f3n <ul> <li>La clase <code>Main</code> ya no tiene la dependencia de <code>Die</code>, que s\u00f3lo est\u00e1 en <code>Player</code>.</li> </ul> hidedelegate/refactored/Main.java<pre><code>public class Main {\n    private Player player;\n\n    public Main () {\n        init();\n    }\n\n    private void init () {\n        player = new Player();\n    }\n\n    public int roll () {\n        return player.roll();\n    }\n}\n</code></pre> <p>``` java title=\"hidedelegate/refactored/Player.java\" hl_lines=\"\" public class Player {     private Die die;</p> <pre><code>public Player () {\n    this.die = new Die();\n}\n\npublic int roll() {\n    return die.roll();\n}\n</code></pre> <p>} <code></code> java title=\"hidedelegate/refactored/Die.java\" hl_lines=\"\" public class Die {     private Random random = new Random();      public int roll() {         return random.nextInt(6) + 1;     } } ```</p>"},{"location":"cleancode/refactoring.html#introducir-metodo-externo","title":"Introducir m\u00e9todo externo","text":"<p>A\u00f1adir un m\u00e9todo en la clase cliente para extender la funcionalidad de otra clase a la que no tenemos acceso.</p> C\u00f3digo mejorable... <ul> <li>El m\u00e9todo <code>improvePassword</code> completa un String de asteriscos si este es muy corto.</li> </ul> <p><code>java title=\"introduceforeignmethod/PasswordChecker.java\" hl_lines=\"\" public class PasswordChecker {     public String improvePassword (String password) {         if (password.length() &lt; 5) {             return \"****\" + password + \"****\";         } else {             return password;         }     } }</code></p> <p>En IntelliJ IDEA, seleccionar el m\u00e9todo/variable y <code>Refactor &gt; Rename</code>.</p> Refactorizaci\u00f3n <ul> <li>Extendemos la funcionalidad de la clase <code>String</code> completando con el propio password dado la vuelta si este es muy corto.</li> </ul> <p>``` java title=\"introduceforeignmethod/refactored/PasswordChecker.java\" hl_lines=\"\" public class PasswordChecker {     public String improvePassword (String password) {         if (password.length() &lt; 5) {             return makeItPalindrome(password);         } else {             return password;         }     }</p> <pre><code>// We extend String functionality\nprivate static String makeItPalindrome (String password) {\n    return new String(password + new StringBuilder(password)\n                                                    .reverse()\n                                                    .toString());\n}\n</code></pre> <p>} ```</p>"},{"location":"cleancode/refactoring.html#introducir-extension-local","title":"Introducir extensi\u00f3n local","text":"<p>Extender una clase para darle una nueva funcionalidad.</p> C\u00f3digo mejorable... <ul> <li>Suponemos que no tenemos acceso a <code>Conversor</code> para a\u00f1adir nuevos m\u00e9todos.</li> </ul> <p>``` java title=\"introducelocalextension/Main.java\" hl_lines=\"\" public class Main {     private Conversor conversor = new Conversor();</p> <pre><code>public double convert (double amount) {\n    return conversor.euro2Dollar(amount);\n}\n</code></pre> <p>} <code></code> java title=\"introducelocalextension/Conversor.java\" hl_lines=\"\" public class Conversor {     public double euro2Dollar (double qty) {         return qty * 1.4d;     }      public double dollar2Euro (double qty) {         return qty * 0.6d;     } } ```</p> <p>En IntelliJ IDEA, seleccionar el m\u00e9todo/variable y <code>Refactor &gt; Rename</code>.</p> Refactorizaci\u00f3n <ul> <li>Creamos una subclase <code>CoolConversor</code> de <code>Conversor</code> con sus funciones y a\u00f1adimos las nuevas que necesitemos.</li> </ul> <p>``` java title=\"introducelocalextension/refactored/Main.java\" hl_lines=\"\" public class Main {     private CoolConversor conversor = new CoolConversor();</p> <pre><code>public double convert (double amount) {\n    return conversor.euro2Dollar(amount);\n}\n</code></pre> <p>} <code></code> java title=\"introducelocalextension/refactored/CoolConversor.java\" hl_lines=\"\" public class CoolConversor extends Conversor {     public double euro2Pound (double qty) {         return qty * 0.8d;     }      public double pound2Euro (double qty) {         return qty * 1.3d;     } } ```</p> <p>``` java title=\"introducelocalextension/refactored/Conversor.java\" hl_lines=\"\" public class Conversor {     public double euro2Dollar (double qty) {         return qty * 1.4d;     }</p> <pre><code>public double dollar2Euro (double qty) {\n    return qty * 0.6d;\n}\n</code></pre> <p>} ```</p>"},{"location":"cleancode/refactoring.html#reemplazar-un-dato-con-un-objeto","title":"Reemplazar un dato con un objeto","text":"<p>Reemplazar un atributo de una clase por un objeto porque necesite que le dotemos de alg\u00fan comportamiento m\u00e1s amplio.</p> C\u00f3digo mejorable... <ul> <li>Campo <code>address</code> se queda corto en este caso porque necesitamos diferenciar la ciudad, c\u00f3digo postal...</li> </ul> replacedatawithobject/Customer.java<pre><code>public class Customer {\n    private String name;\n    private String email;\n    private String address;\n\n    public Customer(String name, String email, String address) {\n        this.name = name;\n        this.email = email;\n        this.address = address;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    @Override\n    public String toString() {\n        return \"Customer [name=\" + name + \", email=\" + email + \", address=\" + address + \"]\";\n    }\n}\n</code></pre> Refactorizaci\u00f3n <ul> <li>Se extrae <code>address</code> a un objeto para poder diferenciar las partes de la propia direcci\u00f3n.</li> </ul> replacedatawithobject/refactored/Customer.java<pre><code>public class Customer {\n    private String name;\n    private String email;\n    private Address address;\n\n    public Customer(String name, String email, Address address) {\n        this.name = name;\n        this.email = email;\n        this.address = address;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public Address getAddress() {\n        return address;\n    }\n\n    public void setAddress(Address address) {\n        this.address = address;\n    }\n\n    @Override\n    public String toString() {\n        return \"Customer [name=\" + name + \", email=\" + email + \", address=\" + address + \"]\";\n    }\n}\n</code></pre> <p>``` java title=\"replacedatawithobject/refactored/Address.java\" hl_lines=\"\" public class Address {     private String street;     private String po;     private String city;</p> <pre><code>public Address(String street, String po, String city) {\n    this.street = street;\n    this.po = po;\n    this.city = city;\n}\n\n@Override\npublic String toString() {\n    return city;\n}\n</code></pre> <p>} ```</p>"},{"location":"cleancode/refactoring.html#encapsular-coleccion","title":"Encapsular colecci\u00f3n","text":"<p>ES com\u00fan que al a\u00f1adir los getters de forma autom\u00e1tica, se a\u00f1ada un get de una colecci\u00f3n que no deber\u00edamos devolver. Esta refactorizaci\u00f3n consiste en encapsular esa colecci\u00f3n, ocultand\u00e1ndola para que est\u00e9 disponible s\u00f3lo a trav\u00e9s de los m\u00e9todos que nos interese.</p> C\u00f3digo mejorable... <ul> <li>El m\u00e9todo <code>getPlayers</code> devuelve la colecci\u00f3n completa de jugadores y no deber\u00eda ser as\u00ed.</li> </ul> encapsultacollection/Team.java<pre><code>public class Team {\n    private String name;\n    private Date creation;\n    private ArrayList&lt;Player&gt; players = new ArrayList&lt;Player&gt;();\n\n    public Team(String name, Date creation) {\n        this.name = name;\n        this.creation = creation;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public Date getCreation() {\n        return creation;\n    }\n\n    public ArrayList&lt;Player&gt; getPlayers() {\n        return players;\n    }\n\n    public int totalPlayers() {\n        return players.size();\n    }\n}\n</code></pre> Refactorizaci\u00f3n <ul> <li>Se crean m\u00e9todos <code>getPlayer</code>, <code>addPlayer</code> y <code>removePlayer</code> para gestionar la colecci\u00f3n sin necesidad de devolverla.</li> </ul> encapsultacollection/refactored/Team.java<pre><code>public class Team {\n    private String name;\n    private Date creation;\n    private ArrayList&lt;Player&gt; players = new ArrayList&lt;Player&gt;();\n\n    public Team(String name, Date creation) {\n        this.name = name;\n        this.creation = creation;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public Date getCreation() {\n        return creation;\n    }\n\n    public Player getPlayer (int index) {\n        return players.get(index);\n    }\n\n    public void addPlayer (Player player) {\n        players.add(player);\n    }\n\n    public void removePlayer (int index) {\n        players.remove(index);\n    }\n\n    public int totalPlayers() {\n        return players.size();\n    }\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#pull-up","title":"Pull up","text":"<p>Subir atributos y m\u00e9todos comunes entre clases hijas, a la superclase.</p> C\u00f3digo mejorable... <ul> <li>El atributo <code>plate</code> (matr\u00edcula) y el m\u00e9todo <code>start</code> est\u00e1n repetidos en las clases hijas.</li> </ul> <p>``` java title=\"pullup/Vehicle.java\" hl_lines=\"\" public class Vehicle {     protected String name; } <pre><code>``` java title=\"pullup/Car.java\" hl_lines=\"2 6\"\npublic class Car extends Vehicle {\n    private String plate;\n    private String trunk;\n    private boolean isTrunkOpened;\n\n    public void start() { ... }\n\n    public boolean isTrunkOpen() {\n        return isTrunkOpened;\n    }\n}\n</code></pre></p> pullup/MotorBike.java<pre><code>public class MotorBike extends Vehicle {\n    private String plate;\n    private String helmet;\n\n    public void start() { ... }\n}\n</code></pre> <p>En IntelliJ IDEA, seleccionar el m\u00e9todo/variable y <code>Refactor &gt; Pull Members Up</code>.</p> Refactorizaci\u00f3n <ul> <li>Se sube a la clase padre el atributo com\u00fan <code>plate</code> y m\u00e9todo com\u00fan <code>start</code>.</li> </ul> pullup/refactored/Vehicle.java<pre><code>public class Vehicle {\n    protected String name;\n    protected String plate;\n\n    public void start() { ... }\n}\n</code></pre> pullup/refactored/Car.java<pre><code>public class Car extends Vehicle {\n    private String trunk;\n    private boolean isTrunkOpened;\n\n    public boolean isTrunkOpen() {\n        return isTrunkOpened;\n    }\n}\n</code></pre> pullup/refactored/MotorBike.java<pre><code>public class MotorBike extends Vehicle {\n    private String helmet;\n}\n</code></pre>"},{"location":"cleancode/refactoring.html#push-down","title":"Push down","text":"<p>La refactorizaci\u00f3n contraria a la anterior. Ocurre cuando hay atributos o m\u00e9todos de una superclase que no tienen sentido en todas las clases hijas. En ese caso, se mueven a las clases hijas que correspondan.</p> C\u00f3digo mejorable... <ul> <li>En una clase hija <code>Bicycle</code> no tiene sentido los atributos de matr\u00edcula, seguro, ni el m\u00e9todo arrancar.</li> </ul> pushdown/Vehicle.java<pre><code>public class Vehicle {\n    protected String name;\n    protected String plate;\n    protected Insurance insurance;\n\n    public void start() { ...  }\n}\n</code></pre> <p>En IntelliJ IDEA, seleccionar el m\u00e9todo/variable y <code>Refactor &gt; Push Members Down</code>.</p> Refactorizaci\u00f3n <ul> <li>Los atributos y m\u00e9todos se pasan a las clase que los utilicen.</li> </ul> <p>``` java title=\"pushdown/refactored/Vehicle.java\" hl_lines=\"\" public class Vehicle {     protected String name; } <pre><code>``` java title=\"pushdown/refactored/Car.java\" hl_lines=\"4 5 11\"\npublic class Car extends Vehicle {\n    private String trunk;\n    private boolean isTrunkOpened;\n    protected String plate;\n    protected Insurance insurance;\n\n    public boolean isTrunkOpen() {\n        return isTrunkOpened;\n    }\n\n    public void start() { ... }\n}\n</code></pre></p> <p><code>java title=\"pushdown/refactored/Bicycle.java\" hl_lines=\"\" public class Bicycle extends Vehicle {     private String helmet; }</code></p>"},{"location":"cleancode/refactoring.html#reemplazar-array-con-objeto","title":"Reemplazar array con objeto","text":"<p>Cuando tenemos un array simplemente para almacenar una serie de datos variados, se puede reemplazar por un objeto con dichos datos para hacer el c\u00f3digo m\u00e1s legible.</p> C\u00f3digo mejorable... <ul> <li>El array <code>pilotData</code> se usa para almacenar datos variados sobre el piloto.</li> </ul> replacearraywithobject/Airplane.java<pre><code>public class Airplane {\n    private String model;\n    private String pilotData[] = new String[3];\n\n    public Airplane(String model) {\n        this.model = model;\n    }\n\n    public void initPilot(String name, String license, int flightHours) {\n        pilotData[0] = name;\n        pilotData[1] = license;\n        pilotData[2] = Integer.toString(flightHours);\n    }\n\n    @Override\n    public String toString() {\n        return \"Airplane [model=\" + model + \", pilot=\" + pilotData[0] + \"]\";\n    }\n}\n</code></pre> Refactorizaci\u00f3n <ul> <li>Se crea una clase <code>Pilot</code> cuyos atributos son los datos que se almacenaban en el array. </li> </ul> replacearraywithobject/refactored/Airplane.java<pre><code>public class Airplane {\n    private String model;\n    private Pilot pilot;\n\n    public Airplane(String model) {\n        this.model = model;\n    }\n\n    public void initPilot(String name, String license, int flightHours) {\n        pilot = new Pilot(name, license, flightHours);\n    }\n\n    @Override\n    public String toString() {\n        return \"Airplane [model=\" + model + \", pilot=\" + pilot + \"]\";\n    }\n}\n</code></pre> <p>``` java title=\"replacearraywithobject/refactored/Pilot.java\" hl_lines=\"\" public class Pilot {     private String name;     private String license;     private int flightHours;</p> <pre><code>public Pilot (String name, String license, int flightHours) {\n    this.name = name;\n    this.license = license;\n    this.flightHours = flightHours;\n}\n\npublic String toString() {\n    return name;\n}\n</code></pre> <p>} ```</p>"}]}